


A_star_homotopies:
  
Inputs: start vertex x_s, goal vertex x_g, heuristic function g
    cost function c, with weights a, b for uncertainty and path length respectively,
    number max_hom_classes of desired target homotopy classes to generate
  
Outputs:
    The optimal path based on the input cost function, for each of the max_hom_classes best-performing homotopy classes  

procedure A_star_homotopies:
    Initialize closed_set = {}
    Initialize open_set = {}
    Initialize optimal_paths = {homotopy class hc : optimal path for hc}
    
    //! Change: we now set a capacity for each vertex
    // for each vertex, vertex_homotopies will only keep the best max_hom_classes classes by g_score
    Initialize vertex_homotopies = {vertex v : [hc such that hc.endpoint_vertex = v]}
    Define start homotopy class hc_s:
        hc_s.Lvalue = 0 + 0i
        hc_s.parent = ⊥
        hc_s.g_score = 0
        hc_s.f_score = h(x_s, x_g)
        hc_s.endpoint_vertex = x_s
    vertex_homotopies.insert{x_s : hc_s}
    open_set.insert{hc_s}
    while (open_set is not empty)
        Set hc_c = open_set.dequeue_min()
        closed_set.add(hc_c)
        Set x_c = hc_c.endpoint_vertex
        if (x_c = x_g) 
            optimal_paths.insert{hc_c : backtrack(hc_c)}
            filled_hom_classes = filled_hom_classes + 1
            
            //! Change: now only rely on open_set is empty condition to terminate
        for (x_n in outnbr(x_c))  
            if (x_n is not accessible) 
                continue
            Set neighbor_Lvalue = hc_c.Lval + Lvalue(x_c, x_n)
            
            //! Change: we use a boolean to mark whether a class was discovered 
            Set discovered = false
            Set hc_n = vertex_homotopies.find {x_n : hc such that hc.Lvalue = neighbor_Lvalue}
            if (hc_n = ⊥)
                Set discovered = true
                hc_n.Lval = neighbor_Lvalue
                hc_n.parent = ⊥
                hc_n.g_score = INFINITY
                hc_n.f_score = INFINITY
                hc_n.endpoint_vertex = x_n
                
                //! Change: not inserting here in set anymore 
            if (closed_set.contains(hc_n))
                continue
            Set tent_g = hc_c.g_score + c(x_x, x_n)
            if (tent_g >= hc_n.g_score)
                continue
            Set hc_n.parent  = hc_c
            Set hc_n.g_score = tent_g
            Set hc_n.f_score = tent_g + h(x_n, x_g)
            
            //! Change: added conditions for discovered classes to enter the set
            if discovered:
                vertex_homotopies.insert {x_n : hc_n}
                if hc_n not inserted:
                    continue
                // truncated is the removed homotopy class if the set is up to capacity and hc_n is inserted
                if some hc' truncated:
                    open_set.remove(hc')
            if (open_set.contains(hc_n))
                open_set.decrease_key(hc_n)
            else 
                open_set.insert(hc_n)

    //! Change: single return at the end
    return optimal_paths
    




    \State $\text{vertex\_homotopies\_map}.insert\{x_n: hc_n\}$