
import sys
import numpy as np
import elliptical_surface_graph as esg
import matplotlib.pyplot as plt
import matplotlib
import re

# A_star_output_path_key = "(-19.80 + -61.57i)"
output_path_key_format = "a=%.2f, b=%.2f, L=(%.2f + %.2fi)" # from astar.c

# Corresponding regex pattern to match and extract L value from the key
pattern = r"L=\((-?\d+\.\d+) \+ (-?\d+\.\d+)i\)"

# Add here paths generated by graph algorithms 
def plot_A_star_output_path(path, ax, z_height=0, color='orange', label='A* Path'):
    """
    Plot a given A* path on an existing 3D plot.
    
    Parameters:
        path (list of list): The path points as [[x1, y1], [x2, y2], ..., [xn, yn]].
        z_height (float): The height at which to plot the path.
        ax (matplotlib.axes.Axes3D): The existing 3D axes to plot on.
        color (str): Color of the path line.
    """
    # Extract x and y coordinates from the path
    x_coords = [point[0] for point in path]
    y_coords = [point[1] for point in path]
    # Create a list of the z_height repeated for each point
    z_coords = [z_height] * len(path)
    
    # Plot the path
    ax.plot(x_coords, y_coords, z_coords, color=color, marker='o', linestyle='-', markersize=1, linewidth=1, label=label)


# This method graphs the set of paths corresponding to each homotopy based on the output path key format
def plot_A_star_homotopies_output_paths(params, ax, z_height=0):
    # Group paths by the L value
    L_groups = {}
    for key, path in params.items():
        match = re.search(pattern, key)
        if match:
            L_value = match.group(1)
            if L_value not in L_groups:
                L_groups[L_value] = []
            L_groups[L_value].append((key, path))
        else:
            print(f"Skipping key with invalid format: {key}")
    # Assign a unique color for each L group
    cmap = matplotlib.colormaps.get_cmap('viridis')
    colors = cmap(np.linspace(0, 1, len(L_groups)))
    color_index = 0
    for L_value, paths in L_groups.items():
        color = colors[color_index]
        for key, path in paths:
            plot_A_star_output_path(path, ax, z_height=z_height, color=color, label=key)
        color_index += 1
    
# Main routine handling ALL graphing procedures:
def generate_path_n_surface_graph(
        params,
        coarsing_factor = 10,
        z_lim = (0, 5), 
        input_figsize = (10,8)
    ):
    # Function-local import statement 
    import matplotlib.pyplot as plt

    # (1) Create figure object
    fig = plt.figure(figsize=input_figsize)

    # (2) Create axis object
    ax = fig.add_subplot(111, projection='3d') # granularily create a set of INDEPENDENT axes

    # (3) Eventually add further independent datasets to global axis object 
    esg.plot_base_rings(params, ax) # Plot the base rings & surface
    # plot_A_star_output_path(params[A_star_output_path_key], ax, z_height=0, color='orange') # output graph
    plot_A_star_homotopies_output_paths(params, ax)
    
    # NOTE: Recompute coarser version of g_image
    X, Y = esg.compute_meshgrids(params, coarsing_factor)
    g_image_coarse = esg.compute_g_image(params, X, Y)
    #ax.plot_surface(X, Y, np.array(g_image_coarse), rstride=1, cstride=1, alpha=0.7) # rstride and cstrinde represent sampling frequency for rows & columns in the meshgrids

    # Set axis limits (inputs)
    ax.set_xlim(params['x_min'], params['x_max'])
    ax.set_ylim(params['y_min'], params['y_max'])
    ax.set_zlim(z_lim[0], z_lim[1])

    # Label the axes
    ax.set_xlabel('X axis')
    ax.set_ylabel('Y axis')
    ax.set_zlabel('Z axis')

    # Title and showing the plot
    ax.set_title('3D Parametric Surface of Ellipses')
    plt.tight_layout()
    plt.show()

# Takes as argument the filepath for the json file storing the parameters
def main():
    # Check if exactly one argument (besides the program name) is given
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <input_filepath>")
        sys.exit(1)  # Exit the program indicating an error

    # Assign the command-line argument to a variable
    input_filepath = sys.argv[1]

    # Print the parsed arguments for debugging
    print(f"The input file path is: {input_filepath}")

    # Load parameters from .json file (already contains computed g_image and output path)
    params = esg.load_parameters(input_filepath)
    generate_path_n_surface_graph(params)


if __name__ == '__main__':
    main()

